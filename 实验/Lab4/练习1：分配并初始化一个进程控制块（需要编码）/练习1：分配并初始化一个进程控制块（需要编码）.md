### 练习1：分配并初始化一个进程控制块（需要编码）

alloc_proc函数（位于kern/process/proc.c中）负责分配并返回一个新的struct proc_struct结构，用于存储新建立的内核线程的管理信息。ucore需要对这个结构进行最基本的初始化，你需要完成这个初始化过程。

请在实验报告中简要说明你的设计实现过程。请回答如下问题：

- 请说明proc_struct中`struct context context`和`struct trapframe *tf`成员变量含义和在本实验中的作用是啥？（提示通过看代码和编程调试可以判断出来）

```c
// alloc_proc - alloc a proc_struct and init all fields of proc_struct
static struct proc_struct *
alloc_proc(void)
{
    struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));
    if (proc != NULL)
    {
        // LAB4:EXERCISE1 2311272
        /*
         * below fields in proc_struct need to be initialized
         *       enum proc_state state;                      // Process state
         *       int pid;                                    // Process ID
         *       int runs;                                   // the running times of Proces
         *       uintptr_t kstack;                           // Process kernel stack
         *       volatile bool need_resched;                 // bool value: need to be rescheduled to release CPU?
         *       struct proc_struct *parent;                 // the parent process
         *       struct mm_struct *mm;                       // Process's memory management field
         *       struct context context;                     // Switch here to run process
         *       struct trapframe *tf;                       // Trap frame for current interrupt
         *       uintptr_t pgdir;                            // the base addr of Page Directroy Table(PDT)
         *       uint32_t flags;                             // Process flag
         *       char name[PROC_NAME_LEN + 1];               // Process name
         */
        proc->state = PROC_UNINIT;
        proc->pid = -1;
        proc->runs = 0;
        proc->kstack = 0;
        proc->need_resched = 0;
        proc->parent = NULL;
        proc->mm = NULL;
        memset(&(proc->context), 0, sizeof(struct context));
        proc->tf = NULL;
        proc->pgdir = boot_pgdir_pa;
        proc->flags = 0;
        memset(proc->name, 0, PROC_NAME_LEN + 1);
    }
    return proc;
}
```

`alloc_proc` 函数负责分配并初始化一个进程控制块（PCB），为创建新进程做准备。

```
static struct proc_struct *alloc_proc(void)
{
    struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));
```

- 使用 `kmalloc` 动态分配内存空间给新的进程控制块
- `proc` 是指向新分配的结构体的指针

```
if (proc != NULL)
{
    // 初始化各个字段
    proc->state = PROC_UNINIT;          // 进程状态设为未初始化
    proc->pid = -1;                     // PID设为-1（无效值）
    proc->runs = 0;                     // 运行次数初始为0
    proc->kstack = 0;                   // 内核栈地址初始为0
    proc->need_resched = 0;             // 不需要重新调度
    proc->parent = NULL;                // 父进程指针为空
    proc->mm = NULL;                    // 内存管理结构为空（内核线程）
```

- **关键字段初始化**：
  - `state`: 设置为 `PROC_UNINIT`，表示进程还未准备好运行
  - `pid`: 设为-1，后续由 `get_pid()` 分配有效PID
  - `kstack`: 设为0，后续由 `setup_kstack()` 分配内核栈

```
    memset(&(proc->context), 0, sizeof(struct context));
    proc->tf = NULL;
```

- **上下文和陷阱帧初始化**：
  - `context`: 使用 `memset` 清零，确保所有寄存器值为0
  - `tf`: 设为NULL，后续在进程创建时设置

```
    proc->pgdir = boot_pgdir_pa;        // 使用内核页目录表
    proc->flags = 0;                    // 标志位清零
    memset(proc->name, 0, PROC_NAME_LEN + 1);  // 进程名清零
```

- **页表和标识初始化**：
  - `pgdir`: 使用内核的页目录表物理地址，内核线程共享内核地址空间
  - `flags`: 进程标志清零
  - `name`: 进程名称数组清零

```
    return proc;
}
```

- **返回初始化完成的进程控制块指针**

#### 问题回答

`context`中保存了进程执行的上下文，也就是几个关键的寄存器的值。这些寄存器的值用于在进程切换中还原之前进程的运行状态，其中包含了`ra`，`sp`，`s0~s11`共14个寄存器。

**在本实验中的作用**：

1. **进程切换时的状态保存**：当进程被切换出去时，当前CPU状态保存到该进程的context中
2. **进程恢复时的状态恢复**：当进程被切换回来时，从context恢复之前保存的状态
3. **实现上下文切换**：`switch_to` 函数使用context在进程间切换

`tf`里保存了进程的中断帧。当进程从用户空间跳进内核空间的时候，进程的执行状态被保存在了中断帧中（注意这里需要保存的执行状态数量不同于上下文切换）。保存了该进程的寄存器状态、栈指针、程序计数器（PC）等关键信息

**在本实验中的作用**：

在内核线程创建的过程中，kernel_thread 函数通过一个局部变量 tf 来放置保存内核线程的临时中断帧。

给中断帧分配完空间后，就需要构造新进程的中断帧，具体过程是：首先给tf进行清零初始化，随后设置设置内核线程的参数和函数指针。要特别注意对tf.status的赋值过程，其读取sstatus寄存器的值，然后根据特定的位操作，设置SPP和SPIE位，并同时清除SIE位，从而实现特权级别切换、保留中断使能状态并禁用中断的操作。