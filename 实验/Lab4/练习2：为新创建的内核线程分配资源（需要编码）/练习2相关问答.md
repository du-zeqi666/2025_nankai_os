### 练习2：为新创建的内核线程分配资源（需要编码）

创建一个内核线程需要分配和设置好很多资源。kernel_thread函数通过调用**do_fork**函数完成具体内核线程的创建工作。do_kernel函数会调用alloc_proc函数来分配并初始化一个进程控制块，但alloc_proc只是找到了一小块内存用以记录进程的必要信息，并没有实际分配这些资源。ucore一般通过do_fork实际创建新的内核线程。do_fork的作用是，创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同。因此，我们**实际需要"fork"的东西就是stack和trapframe**。在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态。你需要完成在kern/process/proc.c中的do_fork函数中的处理过程。它的大致执行步骤包括：

- 调用alloc_proc，首先获得一块用户信息块。
- 为进程分配一个内核栈。
- 复制原进程的内存管理信息到新进程（但内核线程不必做此事）
- 复制原进程上下文到新进程
- 将新进程添加到进程列表
- 唤醒新进程
- 返回新进程号

请在实验报告中简要说明你的设计实现过程。请回答如下问题：

- 请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。

```c
/* do_fork -     parent process for a new child process
 * @clone_flags: used to guide how to clone the child process
 * @stack:       the parent's user stack pointer. if stack==0, It means to fork a kernel thread.
 * @tf:          the trapframe info, which will be copied to child process's proc->tf
 */
int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf)
{
    int ret = -E_NO_FREE_PROC;
    struct proc_struct *proc;
    if (nr_process >= MAX_PROCESS)
    {
        goto fork_out;
    }
    ret = -E_NO_MEM;
    // LAB4:EXERCISE2 2310422
    /*
     * Some Useful MACROs, Functions and DEFINEs, you can use them in below implementation.
     * MACROs or Functions:
     *   alloc_proc:   create a proc struct and init fields (lab4:exercise1)
     *   setup_kstack: alloc pages with size KSTACKPAGE as process kernel stack
     *   copy_mm:      process "proc" duplicate OR share process "current"'s mm according clone_flags
     *                 if clone_flags & CLONE_VM, then "share" ; else "duplicate"
     *   copy_thread:  setup the trapframe on the  process's kernel stack top and
     *                 setup the kernel entry point and stack of process
     *   hash_proc:    add proc into proc hash_list
     *   get_pid:      alloc a unique pid for process
     *   wakeup_proc:  set proc->state = PROC_RUNNABLE
     * VARIABLES:
     *   proc_list:    the process set's list
     *   nr_process:   the number of process set
     */

    //    1. call alloc_proc to allocate a proc_struct
    //    2. call setup_kstack to allocate a kernel stack for child process
    //    3. call copy_mm to dup OR share mm according clone_flag
    //    4. call copy_thread to setup tf & context in proc_struct
    //    5. insert proc_struct into hash_list && proc_list
    //    6. call wakeup_proc to make the new child process RUNNABLE
    //    7. set ret vaule using child proc's pid
    if ((proc = alloc_proc()) == NULL) {
        goto fork_out;
    }

    //    2. call setup_kstack to allocate a kernel stack for child process
    if (setup_kstack(proc) != 0) {
        goto bad_fork_cleanup_proc;
    }

    //    3. call copy_mm to dup OR share mm according clone_flag
    if (copy_mm(clone_flags, proc) != 0) {
        goto bad_fork_cleanup_kstack;
    }

    //    4. call copy_thread to setup tf & context in proc_struct
    copy_thread(proc, stack, tf);

    //    5. insert proc_struct into hash_list && proc_list
    bool intr_flag;
    local_intr_save(intr_flag);
    {
        proc->pid = get_pid();
        hash_proc(proc);
        list_add(&proc_list, &(proc->list_link));
        nr_process++;
    }
    local_intr_restore(intr_flag);

    //    6. call wakeup_proc to make the new child process RUNNABLE
    wakeup_proc(proc);

    //    7. set ret vaule using child proc's pid
    ret = proc->pid;
fork_out:
    return ret;

bad_fork_cleanup_kstack:
    put_kstack(proc);
bad_fork_cleanup_proc:
    kfree(proc);
    goto fork_out;
}
```

do_fork函数主要做了以下7件事情：

1. 分配并初始化进程控制块（`alloc_proc`函数）
2. 分配并初始化内核栈（`setup_stack`函数）
3. 根据`clone_flags`决定是复制还是共享内存管理系统（`copy_mm`函数）
4. 设置进程的中断帧和上下文（`copy_thread`函数）
5. 把设置好的进程加入链表
6. 将新建的进程设为就绪态
7. 将返回值设为线程id

是的，利用get_pid(void)。`get_pid()` 算法通过维护 `last_pid`（上次分配值）和 `next_safe`（安全边界）两个静态变量来高效分配唯一PID。算法首先尝试简单递增 `last_pid`，当达到 `next_safe` 边界时，会扫描所有进程来检测冲突并重新确定安全范围：如果发现PID冲突就递增跳过，同时记录比当前PID大的最小已有PID作为新的安全边界。这种设计使得大多数情况下只需O(1)的递增操作，仅在达到边界时才进行O(n)的全表扫描



**练习二**的核心任务是实现 `do_fork` 函数，用来**为新创建的内核线程分配必要的资源**，包括进程控制块（`proc_struct`）、内核栈、上下文（`trapframe`）和内存管理结构（`mm`）。通过这些步骤，系统能够成功创建一个新的内核线程并让它准备好运行。

### 主要步骤： ###

1. **分配进程控制块（`proc_struct`）**：为新线程创建一个管理信息结构。
2. **分配内核栈**：为子线程分配必要的内核栈空间。
3. **复制或共享内存管理信息（`mm`）**：根据 `clone_flags` 设置是否共享父进程的内存管理结构（在本实验中，内核线程的 `mm` 通常是 `NULL`）。
4. **设置上下文**：为新进程设置 `trapframe` 和 `context`，并将返回地址设置为适当的函数入口（如 `forkret`），以便进程切换时恢复上下文。
5. **分配唯一的进程 ID（`pid`）**：确保新进程的 ID 在系统中唯一。
6. **将新进程加入调度队列**：将进程控制块加入进程链表，并将进程状态设置为就绪（`RUNNABLE`）。

### 目标： ###

- 通过 `do_fork`，系统能够创建一个新的内核线程，分配其所需的资源，并将其加入调度系统，以便后续可以由调度器调度执行。

```
/* do_fork - 以当前进程 current 为父进程，创建一个新的子进程
 * @clone_flags: 用来指导如何克隆子进程（是否共享地址空间等）
 * @stack:       父进程的用户栈指针；如果 stack==0，说明是“内核线程”，没有用户栈
 * @tf:          父进程/模板的 trapframe 信息，会被复制到子进程的 proc->tf 中
 */
int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) {
    // 先假定错误是“没有空闲的 PCB”
    int ret = -E_NO_FREE_PROC;
    struct proc_struct *proc;

    // nr_process 表示当前系统中进程数量
    // 如果已经达到上限 MAX_PROCESS，就不能再创建新进程，直接返回错误
    if (nr_process >= MAX_PROCESS) {
        goto fork_out;
    }

    // 如果后续失败，一般都是“内存不够”的错误
    ret = -E_NO_MEM;

    // LAB4:EXERCISE2 你的学号（略）

    /*
     * 一些有用的函数/宏，供参考：
     *   alloc_proc:   分配并初始化一个 proc_struct（练习1 已实现）
     *   setup_kstack: 为子进程分配 KSTACKPAGE 个页作为“内核栈”
     *   copy_mm:      根据 clone_flags，把 current 的 mm 复制或共享给新进程
     *                 如果 clone_flags & CLONE_VM，则“共享”；否则“复制一份”
     *   copy_thread:  在子进程的内核栈顶布置 trapframe，设置好入口地址和栈指针
     *   hash_proc:    把 proc 挂入 hash_list（按 pid 做哈希，加速查找）
     *   get_pid:      为新进程分配一个唯一的 pid（当前系统内不重复）
     *   wakeup_proc:  把 proc->state 设为 PROC_RUNNABLE，使其进入就绪队列
     *
     * 全局变量：
     *   proc_list:    所有进程的双向链表头（双向循环链表）
     *   nr_process:   当前系统中存在的进程数量
     */

    //==================== 1. 调用 alloc_proc 分配 PCB ====================//
    // 这一步“造出一个空壳进程控制块”，里面字段做了基本初始化
    if ((proc = alloc_proc()) == NULL) {
        // 分配失败，直接返回（ret 已经是 -E_NO_MEM）
        goto fork_out;
    }

    //==================== 2. 为子进程分配内核栈 ====================//
    // 每个进程都有自己的内核栈（位于内核地址空间），用于：
    // - 内核态运行时的函数调用栈
    // - 中断/异常时保存硬件现场
    if (setup_kstack(proc) != 0) {
        // 分配内核栈失败，说明内存不够
        // 此时只分配了 PCB，还没分配别的资源，因此只需要回收 PCB
        goto bad_fork_cleanup_proc;
    }

    //==================== 3. 复制 / 共享 mm 结构 ====================//
    // copy_mm 会根据 clone_flags 决定是：
    // - 复制一份父进程的用户地址空间（用户进程的情形）
    // - 还是和父进程共享同一个地址空间（内核线程用不到 mm）
    // 在本实验中我们创建的是“内核线程”，所以一般是让 proc->mm = NULL
    if (copy_mm(clone_flags, proc) != 0) {
        // 复制/共享 mm 失败，此时已经分配了 PCB 和内核栈
        // 需要把内核栈回收，再回收 PCB
        goto bad_fork_cleanup_kstack;
    }

    //==================== 4. 复制执行上下文（trapframe + context） ====================//
    // copy_thread 的作用：
    // 1）在子进程的内核栈顶上放一份 trapframe（proc->tf）
    // 2）把传进来的 tf 内容复制过去，并做一点修改：
    //    - 把 a0 设为 0，让子进程看到 fork 返回值为 0
    //    - 设置好 sp（栈指针）
    // 3）设置 proc->context.ra = forkret, proc->context.sp = proc->tf
    //    这样将来通过 switch_to 切到这个进程时，会先执行 forkret，
    //    再从 trapframe 恢复所有寄存器，最后跳到真正的入口（kernel_thread_entry 等）
    copy_thread(proc, stack, tf);

    //==================== 5. 分配 pid + 加入 hash_list 和 proc_list ====================//
    // 这几步操作会修改全局数据结构（pid 分配、哈希表、全局链表、nr_process），
    // 必须保证原子性，所以需要关闭中断，防止中途被打断导致竞态问题。
    bool intr_flag;
    local_intr_save(intr_flag);      // 关中断，保存原来的中断状态到 intr_flag
    {
        // get_pid() 会扫描当前系统里的所有进程，分配一个“当前未被使用”的 pid
        // 并且和 local_intr_save 组合在一起，保证任意时刻 pid 不重复。
        proc->pid = get_pid();

        // 把新进程挂入 hash_list，后续可以 O(1) 左右根据 pid 查找到它
        hash_proc(proc);

        // 把新进程挂到全局进程链表 proc_list 上
        // proc_list 是一个双向循环链表，保存所有进程
        list_add(&proc_list, &(proc->list_link));

        // 全局进程计数 +1
        nr_process++;
    }
    local_intr_restore(intr_flag);   // 恢复中断开关状态（如果原来是开就再打开）

    //==================== 6. 唤醒子进程，让 scheduler 能调度它 ====================//
    // wakeup_proc 会把 proc->state 从 PROC_UNINIT 改成 PROC_RUNNABLE，
    // 表示这个进程已经准备好可以被调度器选中运行。
    wakeup_proc(proc);

    //==================== 7. 设置返回值为子进程 pid（父进程看到的值） ====================//
    // 对于调用 do_fork 的那个“父进程”来说，返回值就是“子进程 pid”；
    // 对于子进程来说，它的返回值是在 copy_thread 里把 a0 设置为 0 实现的。
    ret = proc->pid;

fork_out:
    // 无论成功还是失败，最后统一从这里返回 ret
    return ret;

//==================== 错误处理路径：按资源分配顺序逆序释放 ====================//

// 如果已经分配了内核栈，但 copy_mm 失败了
bad_fork_cleanup_kstack:
    // 回收内核栈对应的物理页
    put_kstack(proc);

// 如果连 PCB 也分配了，就在这里释放 PCB
bad_fork_cleanup_proc:
    // 释放通过 alloc_proc 分配的 proc_struct
    kfree(proc);
    // 统一走 fork_out，返回对应错误码
    goto fork_out;
}

```

# 🧱 第一部分：先讲清楚——**为什么需要 do_fork？** #

在 Lab4 里我们需要创建第二个内核线程 `initproc`（pid=1）。
 流程是这样的：

```
kernel_thread(init_main)  
        ↓
构造一个 trapframe tf（作为模板）
        ↓
调用 do_fork(clone_flags | CLONE_VM, stack=0, tf)
        ↓
创建一个真正可运行的进程 control block（proc）
```

所以 **do_fork 是真正“造出一个进程实体”的核心函数**。
 你可以把它形容为：

> “alloc_proc 生出来的是一个空壳，do_fork 把它培养成一个能跑、能调度的真正线程。”

------

# 🎯 第二部分：do_fork 做的 7 件大事（超级清楚版） #

下面我用一幅简图你就懂了：

```
          ┌────────────┐
1. 造壳   │ alloc_proc │   ← 只是申请一块内存，给字段设成初始值
          └──────┬─────┘
                 ↓
          ┌────────────┐
2. 给壳装内核栈│ setup_kstack │ ← 栈给谁用？给中断、内核函数用
          └──────┬─────┘
                 ↓
          ┌────────────┐
3. 复制 mm │ copy_mm      │ ← 内核线程 mm=0，后续用户进程才用
          └──────┬─────┘
                 ↓
          ┌────────────┐
4. 设置上下文│ copy_thread │ ← 决定子进程从哪开始执行
          └──────┬─────┘
                 ↓
          ┌────────────┐
5. 分配 pid│ get_pid      │ ← 必须唯一，所以关中断保护
   加入链表│ list_add     │ ← 系统正式“认识”这个进程
          └──────┬─────┘
                 ↓
          ┌────────────┐
6. 唤醒   │ wakeup_proc  │ ← 让子进程变成 RUNNABLE
          └──────┬─────┘
                 ↓
          ┌────────────┐
7. 返回   │ 返回 pid     │ ← 父进程拿到孩子 pid
          └────────────┘
```

一句话总结：

> **do_fork = PCB + 内核栈 + mm + 上下文 + pid + 加入队列 + 变成可运行**

------

# 🧩 第三部分：do_fork 的 7 步实际意思（你讲给老师听用这个） #

下面是你展示时可以逐句读的完整版：

------

### **① alloc_proc：造一个新的 PCB 壳** ###

- 就是“出生”，所有字段被初始化：
  - `state = UNINIT`
  - `pid = -1`
  - `kstack = 0`
  - `mm = NULL`
  - `tf = NULL`
  - `context 全是 0`

**它还不能跑，只是个空模板。**

------

### **② setup_kstack：给它分配内核栈（非常关键）** ###

为什么要内核栈？

- 中断、异常、系统调用切进内核时需要栈
- `switch_to` 切换过去执行内核线程也需要栈

每个线程都有自己的内核栈，互不干扰。

------

### **③ copy_mm：决定地址空间怎么复制** ###

- Lab4：我们只创建内核线程，所以 `proc->mm = NULL`
- 后面 Lab5 的用户进程才会真正复制 mm / 建立独立页表

------

### **④ copy_thread：给子进程准备好第一次执行的“现场”** ###

这是整个 do_fork 最重要的一步。

它做了三件事：

#### ✔ 给 trapframe 找个放的位置 ####

放在子进程内核栈的最顶端：

```
kstack + KSTACKSIZE - sizeof(trapframe)
```

#### ✔ 复制 tf 的内容 ####

但把 **a0 = 0**，这样子进程运行时会“认为 fork 返回 0”。

#### ✔ 设置 context ####

```
context.ra = forkret
context.sp = (proc->tf)
```

所以第一次调度到子进程时：

```
switch_to → forkret → __trapret → 恢复 trapframe → 跑 kernel_thread_entry → 跑 fn
```

完美！

------

### **⑤ 分配唯一 pid + 插入链表（需要关中断）** ###

为什么关中断？

- get_pid、hash_proc、list_add 都是操作全局数据结构
- 不能被时钟中断（schedule）打断，否则链表会乱套

这里 **保证系统中所有 pid 在同一时刻唯一**。

------

### **⑥ wakeup_proc：把状态变为 RUNNABLE** ###

从 UNINIT → RUNNABLE
 调度器（schedule）才有资格调度它。

------

### **⑦ 返回 pid** ###

父进程收到 `pid > 0`
 子进程从 trapframe 恢复后看到 `a0 = 0`
 这一点和 Linux 完全一致。

------

# 🏁 第四部分：一句话总结（你展示最后可以用） #

> 在练习二中，我实现了 do_fork，它负责真正创建一个可运行的内核线程：
>  分配 PCB、分配内核栈、复制 mm、构造 trapframe、设置 context、分配 pid、加入链表、唤醒进程。
>  最终，调度器就可以让这个新线程运行起来。

------

好，咱就死扣这一句思考题：

> **“ucore 是否做到给每个新 fork 的线程一个唯一的 id？请说明你的分析和理由。”**

我帮你拆成三块来理解和说：

1. 先搞清楚题目真正在问什么。
2. 再看 **do_fork + get_pid** 是怎么配合的。
3. 最后给出一个“展示时能直接说”的标准答案。

------

## 一、题目到底在问什么？ ##

它其实在问两件事：

1. **在任意一个时刻，系统里所有活着的线程 / 进程，pid 会不会撞车？**
   - 比如同时有两个线程 pid 都是 5，这样肯定不行。
2. **ucore 的实现有没有从代码层面认真考虑“并发 + 重复分配”的问题？**

注意：

- 它不是在问 “pid 一辈子绝对不重复”——大多数 OS 都会**复用 pid**，
- 问的是：**在同一时间活着的进程 pid 必须唯一**。

所以你回答时要强调：

> “ucore 保证在任意时刻，系统中所有存活进程的 pid 都是唯一的，但 pid 在进程退出后是可以复用的。”

------

## 二、从 do_fork 看：pid 是在哪里分配的？ ##

你的 `do_fork` 里关键一段是这样的（你代码里就有）：

```c
bool intr_flag;
local_intr_save(intr_flag);
{
    proc->pid = get_pid();      // ① 分配 pid
    hash_proc(proc);            // ② 加入哈希表
    list_add(&proc_list, &(proc->list_link)); // ③ 加入全局进程链表
    nr_process++;               // ④ 进程数 +1
}
local_intr_restore(intr_flag);
```

这里有几个非常重要的点：

1. **pid 只能在 `do_fork` 里通过 `get_pid()` 分配**
   - 没有其他地方直接手动改 `pid`；
   - 所以“谁生孩子，谁调用 get_pid”。
2. **这几步是在关中断的临界区里做的**
   - `local_intr_save/restore` 保证：
     - 在这段代码执行过程中，当前 CPU 上不会发生时钟中断；
     - 也就不会发生调度，不会突然切到另一个进程去再调用一次 `do_fork`。
   - 所以，**不会出现两个进程同时执行 get_pid 的情况**。

> 小结一句：
>  “pid 分配只出现在 do_fork 里，并且用关中断把这块代码包成了一个原子操作。”

------

## 三、get_pid 本身是怎么“防撞车”的？ ##

虽然你这里的源码没贴出来，但 ucore 的典型实现套路是这样的（伪代码）：

```c
static int last_pid = 0;
static int next_safe = MAX_PID;   // 一个“安全边界”

int get_pid(void) {
    again:
    // 1. 先简单地递增 last_pid
    last_pid ++;
    if (last_pid >= MAX_PID) {
        last_pid = 1;             // 跑到上限了就从 1 重新开始
    }

    // 2. 如果 last_pid 还没到 next_safe，说明这段区间里肯定没人占用
    if (last_pid < next_safe) {
        return last_pid;          // 直接用，O(1)
    }

    // 3. 否则，就要“慢一点”：扫描当前所有进程，避开已经占用的 pid
    next_safe = MAX_PID;
    for each proc in proc_list {
        if (proc->pid == last_pid) {
            // 撞车了，就 ++last_pid，重新来
            goto again;
        }
        // 顺便记录“比当前 last_pid 大、且最小的那个 pid”
        if (proc->pid > last_pid && proc->pid < next_safe) {
            next_safe = proc->pid;
        }
    }

    // 扫完一圈，没撞车，就可以放心用 last_pid
    return last_pid;
}
```

- `last_pid`：
   记录“上一次分配出去的 pid”，大多数情况下只要简单做 `last_pid++`，速度非常快；
- `next_safe`：
   记录一个“安全上界”：在 `(last_pid, next_safe)` 这个区间中
   **保证没有任何进程在用这些 pid**，所以我们可以放心递增直到 next_safe 之前都不用再扫描。

流程大概是：

1. **快路径（常用情况）**
   - 每次 `get_pid` 时，直接 `last_pid++`；
   - 如果 `last_pid < next_safe`，说明“中间一段没人用”，直接返回这个 pid，不需要扫描链表；
   - 这种情况下是 **O(1)** 的操作。
2. **慢路径（少数情况）**
   - 只有在两种情况才触发：
     - `last_pid` 接近了 `next_safe` 边界；
     - pid 大到快接近 `MAX_PID`，需要回绕重新从 1 开始。
   - 这时扫描所有进程，把“已经用掉的 pid”跳过去：
     - 一旦发现有进程的 pid 和 `last_pid` 一样，就 `++last_pid` 并重新检查；
     - 同时找出比 `last_pid` 更大的最小 pid 作为新的 `next_safe`。
   - 扫完一圈后，`last_pid` 就是一个当前没人用的 pid。

**最关键的一点：**

> 在调用 `get_pid` 的时候，外面已经用 `local_intr_save` 关了中断，
>  所以整个过程对“当前 CPU 来说是不可打断的”，
>  扫描 `proc_list` 时不会有人在同时改 pids 或往里面塞新进程。

------

## 四、那 ucore “是否做到” pid 唯一？怎么回答？ ##

你可以按这几句逻辑回答，很有条理：

1. **从使用层面看：**
   - 所有新创建的进程/线程都通过 `do_fork` 创建；
   - `do_fork` 内部统一调用 `get_pid` 分配 pid；
   - 所以 pid 的来源是单一受控的。
2. **从并发安全性看：**
   - 在 `do_fork` 中，对 `get_pid`、`hash_proc`、`list_add`、`nr_process++` 这一整段操作用 `local_intr_save/restore` 包了一层；
   - 这保证了在 fork 过程中不会被时钟中断打断，也就不会在中途切到另一个进程再次调用 `get_pid`；
   - 在**单核**的实验环境下，这就等价于“同一时间只有一个执行流能分配 pid”。
3. **从 get_pid 算法看：**
   - 通过维护 `last_pid` 和 `next_safe`，一般情况下只做自增操作；
   - 在需要回绕或到达安全边界时，会扫描当前所有进程的 pid，跳过已经在用的 pid；
   - 扫描时依赖的是 `proc_list`，而在分配过程中进程链表不会被并发修改（因为在临界区内）。
4. **关于“唯一”的准确定义：**
   - ucore **保证在任意时刻，系统中所有存活进程的 pid 都不相同**；
   - 当某个 pid 的进程退出并从 `proc_list` 中移除后，这个 pid 将来有机会再次被分配；
   - 也就是说，**pid 会被复用，但不会“撞车”**。

可以用一句收尾话：

> 所以，可以认为 ucore 做到了：
>
> - 在 fork 的那一刻，通过 `local_intr_save` + `get_pid` 的组合，
>    保证了“在同一时刻同一个 pid 只会被分配给一个活着的进程”；
> - 进程退出后 pid 可以被回收再利用，这是刻意为之，不影响“唯一性”的语义。

------

## 五、如果老师继续刨根问到底，你可以顺便加一点 bonus： ##

### 1）如果是真多核 CPU ，这样够吗？ ###

- 严格说，`local_intr_save` 只关**本核**中断，不能阻止别的 CPU 核同时执行 `do_fork`。
- 真正的 SMP 系统通常还需要一个**全局锁**（比如 `spinlock`）保护 pid 分配和全局链表；
- 但 ucore 的实验环境是单核 + QEMU 模拟，本身就是单执行流，所以关中断就足够。

你可以补一句：

> “在教学场景下，单核系统用关中断足够保证 pid 分配的原子性，如果要扩展成多核，需要再加锁。”

------

## 六、给你一个可以直接背的简版答案（建议记一下） ##

> **问题：ucore 是否做到给每个新 fork 的线程一个唯一的 id？**
>
> 答：从“同一时刻活着的进程 pid 不重复”这个意义上来说，ucore 做到了。
>  具体来说，所有新线程都是通过 `do_fork` 创建的，`do_fork` 在关中断的临界区内调用 `get_pid` 分配 pid，并把进程挂入全局的 `proc_list`。这样保证了同一时刻只有一个执行流在分配 pid，不会发生并发竞争。
>
> `get_pid` 内部通过维护 `last_pid` 和 `next_safe`，在大多数情况下只是简单递增 `last_pid`；当到达安全边界或需要回绕时，会扫描当前的进程链表，跳过已经占用的 pid，并更新新的安全边界，从而确保返回的 pid 不与任何现存进程重复。
>
> 因此，在 ucore 中，系统中所有存活进程的 pid 在任何时刻都是唯一的，但 pid 在进程退出、从进程链表中移除之后是可以被复用的。



------

## ① 函数开头：我是谁？要干啥？ ##

```c
int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf)
{
    int ret = -E_NO_FREE_PROC;
    struct proc_struct *proc;
```

- `do_fork(...)`：
   这个函数的任务 = **“照着当前进程，生一个孩子进程出来”**。
- 参数：
  - `clone_flags`：fork 时的一些标志，表示要不要共享地址空间之类的；
  - `stack`：如果是用户进程，可以指定子进程的用户栈；Lab4 的内核线程这里基本是 0；
  - `tf`：一份“模板 trapframe”，用它来给子进程准备初始寄存器状态。
- `int ret = -E_NO_FREE_PROC;`：
   先假设**错误原因**是“没有多余的 PCB 位置”，后面如果成功就会改这个值。
- `struct proc_struct *proc;`：
   将来用来指向“新生的那个进程控制块”。

你可以把这几行理解成：

> “我准备造个孩子，先准备个变量放结果，还准备个指针指向这个孩子的 PCB。”

------

## ② 先看：系统里进程是不是太多了？ ##

```c
    if (nr_process >= MAX_PROCESS)
    {
        goto fork_out;
    }
    ret = -E_NO_MEM;
```

- `nr_process`：当前系统里已经有多少个进程 / 线程了。
- `MAX_PROCESS`：系统允许的最大进程数。
- 如果已经满了，那就**直接跳到 `fork_out` 结束函数**，返回 `ret`（此时是 `-E_NO_FREE_PROC`）。
- `ret = -E_NO_MEM;`：
   过了上面这一关，说明“名额够”，接下来如果出错，多半是“内存不够”，所以把错误默认改成“没内存”。

你可以这样理解：

> 先看“名额满没满”。满了直接说“没位置了”。
>  不满的话，接下来如果失败，就按“没内存”算。

------

## ③ 第一步：造一个 PCB 壳子（alloc_proc） ##

```c
    //    1. call alloc_proc to alloc a proc_struct
    if ((proc = alloc_proc()) == NULL) {
        goto fork_out;
    }
```

- `alloc_proc()` 会：
  - 用 `kmalloc` 分配一块 `struct proc_struct` 空间；
  - 把里面的字段都**清成初始值**，比如：
    - `state = PROC_UNINIT`（还没准备好运行）；
    - `pid = -1`（身份证还没办）；
    - `mm = NULL`、`kstack = 0` 等。
- 如果连 PCB 都分配失败了，那基本就是内存太紧张了 → 直接 `goto fork_out`，返回 `-E_NO_MEM`。

**这是“刚出生，还没长肉”的阶段。**

------

## ④ 第二步：给这个进程分配内核栈 ##

```c
    //    2. call setup_kstack to allocate a kernel stack for child process
    if (setup_kstack(proc) != 0) {
        goto bad_fork_cleanup_proc;
    }
```

- 一个进程/线程在内核态运行的时候，需要有**自己的内核栈**：
  - 函数调用要压栈；
  - 中断/异常进来，要把寄存器压栈。
- `setup_kstack(proc)`：
  - 会给这个进程分配 `KSTACKPAGE` 页物理内存；
  - 把这块内存的虚拟地址放进 `proc->kstack`。

如果这里失败了：

- 已经分配了 PCB（`proc`），但没有栈；
- 所以跳到 `bad_fork_cleanup_proc`，在那里会把 `proc` 给 `kfree` 掉，然后结束。

**你可以把这当成：给新生的进程发了一块“专用栈空间”。**

------

## ⑤ 第三步：复制/共享内存管理结构（copy_mm） ##

```c
    //    3. call copy_mm to dup OR share mm according clone_flag
    if (copy_mm(clone_flags, proc) != 0) {
        goto bad_fork_cleanup_kstack;
    }
```

- `copy_mm(clone_flags, proc)` 做的是：
  - 对“用户进程”来说：决定给子进程**复制一份 mm**，还是**和父进程共享一个 mm**。
  - 对当前 Lab4 的“内核线程”来说：基本就是让 `proc->mm = NULL`，因为内核线程使用统一的内核地址空间。
- 如果失败了：
  - 此时已经有 PCB + 内核栈了，所以要去 `bad_fork_cleanup_kstack`：
    - 先回收内核栈；
    - 再回收 PCB。

**这里是给进程“准备地址空间信息”的地方，但 Lab4 内核线程这块其实还很简单。**

------

## ⑥ 第四步：设置子进程的 trapframe 和 context（copy_thread） ##

```c
    //    4. call copy_thread to setup tf & context in proc_struct
    copy_thread(proc, stack, tf);
```

这一句很短，但是**干的事非常多**，整体可以理解为：

> “把将来子进程第一次运行时需要的寄存器状态、栈指针，全都布置好。”

`copy_thread(proc, stack, tf)` 里面大致会做：

1. 在子进程的内核栈顶上留一块地方放 `trapframe`：

   ```c
   proc->tf = (struct trapframe *)(proc->kstack + KSTACKSIZE - sizeof(struct trapframe));
   *(proc->tf) = *tf;   // 把传进来的 tf 拷贝一份
   ```

2. 修改子进程的 `trapframe`：

   - `proc->tf->gpr.a0 = 0;`
      → 以后子进程从 `fork` 返回时看到的返回值是 0（Unix 语义）。
   - 设置 `sp`（栈指针）为子进程自己的位置。

3. 设置上下文 `context`：

   ```c
   proc->context.ra = (uintptr_t)forkret;
   proc->context.sp = (uintptr_t)(proc->tf);
   ```

   以后调度器 `switch_to` 切换到这个进程时：

   - 会从 `forkret` 开始跑；
   - `forkret` 再跳到 `__trapret`，从 `proc->tf` 里恢复所有寄存器；
   - 最终跳到我们在 `kernel_thread` 里设置好的 `kernel_thread_entry` → 再去跑真正的函数 `fn`。

你可以把这一句当成：

> “把子进程第一次醒来的‘现场照片’做好，等调度器一叫它，它就知道从哪儿开始跑。”

------

## ⑦ 第五步：关中断，分配 pid，挂到全局链表里 ##

```c
    //    5. insert proc_struct into hash_list && proc_list
    bool intr_flag;
    local_intr_save(intr_flag);
    {
        proc->pid = get_pid();
        hash_proc(proc);
        list_add(&proc_list, &(proc->list_link));
        nr_process++;
    }
    local_intr_restore(intr_flag);
```

这一段是**全局登记户口**：

1. `local_intr_save(intr_flag);`

   - 把当前中断状态保存到 `intr_flag`；
   - 然后**关闭中断**，防止中途被打断。

2. 在大括号里干四件事：

   ```c
   proc->pid = get_pid();
   ```

   - 分配一个在当前系统里**不重复的 pid**；
   - `get_pid` 会看 `last_pid`、`next_safe`，必要时还会扫描所有进程以保证不冲突（之前我们已经详细分析过）。

   ```c
   hash_proc(proc);
   ```

   - 把这个进程按 pid 挂到 `hash_list` 里；
   - 以后根据 pid 查进程会很快。

   ```c
   list_add(&proc_list, &(proc->list_link));
   ```

   - 把这个进程塞进全局的 `proc_list`；
   - **自此起，这个进程正式出现在“系统进程列表”里。**

   ```c
   nr_process++;
   ```

   - 全局进程计数 +1。

3. `local_intr_restore(intr_flag);`

   - 把刚才保存的中断状态恢复回去；
   - 如果原来中断是开的，就重新打开。

你可以这样给自己解释：

> “这一段是在做户口登记，必须一口气做完，不能半路被中断打断，所以先关中断，办完手续再恢复。”

------

## ⑧ 第六步：唤醒子进程，让它变成 RUNNABLE ##

```c
    //    6. call wakeup_proc to make the new child process RUNNABLE
    wakeup_proc(proc);
```

- `wakeup_proc(proc)` 做的事情一般是：
  - 把 `proc->state` 设为 `PROC_RUNNABLE`；
  - 让调度器以后可以在 `schedule()` 里选中它来运行。

之前它的状态还是“刚创建好，还不能排队上 CPU”；
 现在是：**“可以排队等 CPU 了”**。

------

## ⑨ 第七步：设置返回值 = 子进程 pid ##

```c
    //    7. set ret vaule using child proc's pid
    ret = proc->pid;
```

- 对于父进程来说，`do_fork` 返回的是**子进程的 pid**；
- 对于子进程来说，它看到的返回值是 0（在 `copy_thread` 里已经设置了 a0=0）。

这和 Linux 的 `fork()` 行为一致：

- 父进程：`fork()` 返回 >0（子 pid）；
- 子进程：`fork()` 返回 0。

------

## ⑩ 尾巴：正常返回 & 出错清理路径 ##

```c
fork_out:
    return ret;

bad_fork_cleanup_kstack:
    put_kstack(proc);
bad_fork_cleanup_proc:
    kfree(proc);
    goto fork_out;
}
```

这几行是**错误处理 + 资源回收**的套路：

1. `fork_out:`

   - 所有路径最后都跳到这里，`return ret;`。

2. 如果在“已经有 PCB + 有内核栈”的阶段失败：

   ```c
   bad_fork_cleanup_kstack:
       put_kstack(proc);
   ```

   - 回收内核栈。

3. 不管是从 `bad_fork_cleanup_kstack` 还是别处跳到 `bad_fork_cleanup_proc`：

   ```c
   bad_fork_cleanup_proc:
       kfree(proc);
       goto fork_out;
   ```

   - 释放 PCB；
   - 再跳到 `fork_out`，返回错误。

**这就是“干到哪儿，出错就把已分配的东西反着释放回去”的标准写法。**

------

## 最后给你一个超级简化版“人话总结” ##

你可以照着这段话讲给老师听：

> `do_fork` 的作用就是：**按照当前进程的状态，创建一个新的子进程，并把它放进调度系统里，等着被调度运行。**
>  我这里的实现一共分七步：
>  1）先检查进程数量有没有超上限；
>  2）用 `alloc_proc` 分配一个 PCB，做最初的初始化；
>  3）用 `setup_kstack` 给这个 PCB 分配自己的内核栈；
>  4）用 `copy_mm` 决定内存管理结构（现在是内核线程，一般 `mm = NULL`）；
>  5）用 `copy_thread` 把子进程第一次运行时的 trapframe 和 context 布置在它的内核栈上；
>  6）在关中断的临界区里，用 `get_pid` 分配唯一 pid，把它挂到全局的链表和哈希表，更新进程数；
>  7）调用 `wakeup_proc` 把它设为 RUNNABLE，再把返回值 `ret` 设为它的 pid。
>  如果中间任何一步失败，就会通过后面的错误标签，把已经分配的资源按相反顺序释放掉，避免内存泄漏。

------

