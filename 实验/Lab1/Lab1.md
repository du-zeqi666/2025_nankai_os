# <center>lab1: 比麻雀更小的麻雀（最小可执行内核）

## 实验报告要求

从oslab网站上取得实验代码后，进入目录labcodes/lab1，完成实验要求的各个练习。在实验报告中回答所有练习中提出的问题。在目录labcodes/lab1下存放实验报告，推荐用**markdown**格式。每个小组建一个gitee或者github仓库，完成实验之后，通过git push命令把代码和报告上传到仓库。最后请一定提前或按时提交到git网站。

## 实验内容：

实验1主要讲解最小可执行内核和启动流程。我们的内核主要在 Qemu 模拟器上运行，它可以模拟一台 64 位 RISC-V 计算机。为了让我们的内核能够正确对接到 Qemu 模拟器上，需要了解 Qemu 模拟器的启动流程，还需要一些程序内存布局和编译流程（特别是链接）相关知识,以及通过opensbi固件来通过服务。

## 实验相关

### gdb使用

GDB 还提供了丰富的调试功能，例如：

- `si`（Step Instruction）：以单条汇编指令为步长单步执行，适用于深入理解底层行为；
- `bt`（BackTrace）：打印函数调用栈，帮助理解执行路径；
- `frame <n>`：切换到调用栈的第 `n` 层，查看该层的局部变量和上下文；
- `x/<format> <address>`：查看内存内容，如 `x/10x $sp` 表示以十六进制显示栈指针后的10个字。

### tips:

启动流程可以分为以下几个阶段：

最小可执行内核的完整启动流程为:

```
加电复位 → CPU从0x1000进入MROM → 跳转到0x80000000(OpenSBI) → OpenSBI初始化并加载内核到0x80200000 → 跳转到entry.S 
```

1) CPU 从复位地址（`0x1000`）开始执行初始化固件（OpenSBI）的汇编代码，进行最基础的硬件初始化。
2) SBI 固件进行主初始化，其核心任务之一是将内核加载到 `0x80200000`。可以使用`watch *0x80200000`观察内核加载瞬间，避免单步跟踪大量代码。
3) SBI 最后跳转到 0x80200000，将控制权移交内核。使用 `b *0x80200000` 可在此中断，验证内核开始执行

`kern/init/entry.S`: OpenSBI启动之后将要跳转到的一段汇编代码。在这里进行内核栈的分配，然后转入C语言编写的内核初始化函数。

`kern/init/init.c`： C语言编写的内核入口点。主要包含`kern_init()`函数，从`kern/init/entry.S`跳转过来完成其他初始化工作。

1. - 

------

## 实验中的重要知识点及与 OS 原理的对应

### 实验中的知识点

1. **内核入口代码 (**entry.S**)**
   - **含义**：entry.S 是内核启动的汇编代码，负责初始化栈并跳转到 C 语言入口点。
   - **OS 原理对应**：操作系统启动流程中的“引导程序”阶段。引导程序（如 Bootloader 或固件）完成硬件初始化后，将控制权移交内核入口。
   - **关系与理解**：实验中的 entry.S 是内核启动的第一段代码，类似于 OS 原理中的 Bootloader 的最后阶段（跳转到内核）。它确保了从汇编到 C 语言环境的平滑过渡。实验中未涉及完整的 Bootloader（如 GRUB），而是由 OpenSBI 代替，简化了流程。
   - **差异**：实验中的 entry.S 只关注栈初始化和跳转，功能较简单，而 OS 原理中的引导程序可能还包括加载内核镜像、设置中断向量等更复杂的操作。
2. **栈初始化**
   - **含义**：通过 la sp, bootstacktop 设置栈指针，确保 C 语言函数调用有合法的栈空间。
   - **OS 原理对应**：运行时环境初始化。操作系统启动时需要为内核分配栈空间，用于支持函数调用和上下文保存。
   - **关系与理解**：栈初始化是内核运行的基础，实验中通过汇编显式设置 sp，体现了 OS 原理中运行时环境准备的重要性。
   - **差异**：实验中栈空间是静态分配的（KSTACKSIZE），而实际 OS 中可能动态分配栈或支持多线程栈管理。
3. **尾调用优化**
   - **含义**：tail kern_init 使用尾调用优化跳转到 kern_init，减少栈开销。
   - **OS 原理对应**：无直接对应的 OS 原理知识点，但与函数调用约定和优化相关。
   - **关系与理解**：尾调用优化是编译器和汇编代码中常见的优化手段，实验中体现了 RISC-V 调用约定的高效性。OS 原理中虽未明确讨论，但与性能优化相关。
   - **差异**：实验中仅在 entry.S 中使用尾调用，而实际 OS 中可能在更多场景使用优化技术。
4. **OpenSBI 的作用**
   - **含义**：OpenSBI 是 RISC-V 的固件，运行在 M 模式，负责硬件初始化和内核加载。
   - **OS 原理对应**：固件或 Bootloader 的作用。OS 启动流程中，固件（如 BIOS/UEFI）完成硬件初始化并加载内核。
   - **关系与理解**：OpenSBI 在实验中替代了传统 Bootloader，完成了从硬件到内核的过渡。OS 原理中的 Bootloader 概念更广，可能包括多阶段加载，而 OpenSBI 专注于 RISC-V 平台的初始化。
   - **差异**：实验中的 OpenSBI 是 RISC-V 特定的固件，功能较固定，而 OS 原理中的 Bootloader 可能因平台不同而有更大差异（如 x86 的 GRUB）。

### 未在实验中体现的重要 OS 原理知识点

1. **多阶段引导程序**
   - **含义**：OS 原理中，启动流程通常包括多阶段引导（如 BIOS → MBR → Bootloader → 内核）。实验中仅涉及 OpenSBI 和 entry.S，省略了前几阶段。
   - **原因**：实验使用 QEMU 模拟器和 OpenSBI，直接从 0x1000 跳转到 0x80000000，简化了引导流程。
2. **中断向量表设置**
   - **含义**：OS 启动时需要初始化中断向量表以处理硬件中断和异常。实验中未涉及这部分，可能是后续实验的内容。
   - **原因**：Lab1 专注于内核入口，尚未涉及中断处理（在 kern/trap 中实现）。
3. **设备树或硬件探测**
   - **含义**：OS 原理中，启动时需要探测硬件配置（如设备树或 ACPI 表）。实验中 OpenSBI 可能隐式完成了部分工作，但未在代码中明确体现。
   - **原因**：实验简化了硬件交互，专注于内核初始化逻辑。

## 实验操作

实验初期环境变量未生效，重新配置RISCV工具链路径后编译成功。

```
make qemu
```

![](pic\屏幕截图 2025-10-07 103218.png)

![](D:\Desktop\各科任务\大三\大三上\操作系统\实验\Lab1\pic\屏幕截图 2025-10-07 103435.png)

### 遇到的问题

qemu4.1.1自带的opensbi不能直接用，用系统的

```
sudo apt install opensbi
```

验证 OpenSBI 固件路径

![](D:\Desktop\各科任务\大三\大三上\操作系统\实验\Lab1\pic\屏幕截图 2025-10-07 110014.png)

说明路径正确

运行

```
qemu-system-riscv64 -machine virt -m 128M -nographic \
  -bios /usr/lib/riscv64-linux-gnu/opensbi/generic/fw_jump.elf \
  -kernel bin/kernel \
  -S -gdb tcp::1234
```

`-bios` 指定你刚安装的 OpenSBI 固件；

`-kernel bin/kernel` 指定编译出的实验内核；

`-S` 让 QEMU 暂停在上电状态；

`-gdb tcp::1234` 开启 GDB 调试端口。

在另一个终端输入：

```
riscv64-unknown-elf-gdb bin/kernel
```

![](D:\Desktop\各科任务\大三\大三上\操作系统\实验\Lab1\pic\屏幕截图 2025-10-07 110248.png)

验证连接是否成功

```assembly
(gdb) target remote :1234
Remote debugging using :1234
0x0000000000001000 in ?? ()
(gdb) info registers pc
pc             0x1000	0x1000
```

查看最开始的指令

```assembly
0x1000: auipc t0, 0x0        # 加载当前 PC（0x1000）到 t0 作为地址基准
0x1004: addi a1, t0, 32      # 计算地址 0x1020（t0+32）到 a1，
0x1008: csrr a0, mhartid     # 读取当前硬件线程 ID 到 a0，支持多核处理
0x100c: ld t0, 24(t0)        # 从地址 0x1018 加载 OpenSBI 入口地址到 t0
0x1010: jr t0                # 跳转到 t0（OpenSBI，0x80000000），移交控制权
0x1014: unimp                # 填充指令，触发异常以防意外执行
```

![](D:\Desktop\各科任务\大三\大三上\操作系统\实验\Lab1\pic\屏幕截图 2025-10-07 153804.png)

首先下断点，我们可以直接对`kern_entry`函数下断点（`b`是`break`的缩写）：

```
(gdb) b* kern_entry
```

![](D:\Desktop\各科任务\大三\大三上\操作系统\实验\Lab1\pic\屏幕截图 2025-10-07 194323.png)

```
si
```

单步执行

```
i r t0
```

观察寄存器值变化

![](D:\Desktop\各科任务\大三\大三上\操作系统\实验\Lab1\pic\屏幕截图 2025-10-07 194927.png)

观察到寄存器值变化，此时为第二阶段**OpenSBI 初始化与内核加载**。CPU 跳转到`0x80000000`处继续运行。OpenSBI 运行在 RISC-V 的最高特权级（M 模式），负责初始化处理器的运行环境。完成这些初始化工作后，OpenSBI 才会准备开始加载并启动操作系统内核。OpenSBI 将编译生成的内核镜像文件加载到物理内存的`0x80200000`地址处。

```assembly
(gdb) x/10i 0x80000000   
=># 地址 0x80000000 是 OpenSBI 的入口地址，从 MROM（0x1000）跳转而来。
# OpenSBI 运行在 M 模式，负责处理器环境初始化和内核加载。

0x80000000: add s0, a0, zero     # 将 a0（mhartid）复制到 s0，保存硬件线程 ID
0x80000004: add s1, a1, zero     # 将 a1复制到 s1，保存参数
0x80000008: add s2, a2, zero     # 将 a2（可能的其他参数）复制到 s2，保存参数
0x8000000c: jal ra, 0x80000548   # 跳转到 0x80000548 并保存返回地址到 ra，调用初始化函数
0x80000010: add a6, a0, zero     # 将初始化函数返回值（a0）复制到 a6，保存结果
0x80000014: add a0, s0, zero     # 恢复 a0 的值（mhartid）从 s0
0x80000018: add a1, s1, zero     # 恢复 a1 的值（设备树地址）从 s1
0x8000001c: add a2, s2, zero     # 恢复 a2 的值（其他参数）从 s2
0x80000020: li a7, -1            # 加载立即数 -1 到 a7，作为比较值
0x80000022: beq a6, a7, 0x8000002a # 如果 a6 等于 -1，跳转到 0x8000002a（可能处理错误）地址不是0x80000022,属于编译器自动指令填充或对齐，0x22 与 0x2a 的偏移是按RISC-V字节对齐（2字节或4字节）产生的，不是错误。
```

![](D:\Desktop\各科任务\大三\大三上\操作系统\实验\Lab1\pic\屏幕截图 2025-10-07 195109.png)

观察启动操作系统的代码

```assembly
(gdb) x/10i 0x80200000
# 地址 0x80200000 是内核入口地址，由 OpenSBI 跳转而来，位于 kern/init/entry.S。
# 负责初始化内核栈并跳转到 kern_init 函数，开始 C 语言初始化。

0x80200000 <kern_entry>: auipc sp, 0x3        # 加载 PC+0x3000 到 sp，设置栈指针初始值
0x80200004 <kern_entry+4>: mv sp, sp          # 无操作（NOP），可能用于对齐或占位
0x80200008 <kern_entry+8>: j 0x8020000a       # 跳转到 kern_init（0x8020000a），进入内核初始化
0x8020000a <kern_init>: auipc a0, 0x3         # 加载 PC+0x3000 到 a0，准备参数或地址
0x8020000e <kern_init+4>: addi a0, a0, -2     # a0 减 2，调整地址（可能指向特定数据结构）
0x80200012 <kern_init+8>: auipc a2, 0x3       # 加载 PC+0x3000 到 a2，准备另一个地址
0x80200016 <kern_init+12>: addi a2, a2, -10   # a2 减 10，调整地址（可能指向另一数据结构）
0x8020001a <kern_init+16>: addi sp, sp, -16   # 栈指针 sp 减 16，分配栈空间
0x8020001e <kern_init+18>: li a1, 0           # 将 a1 设置为 0，可能作为参数传递
0x8020001e <kern_init+20>: sub a2, a2, a0     # a2 = a2 - a0，计算地址差值
```

![](D:\Desktop\各科任务\大三\大三上\操作系统\实验\Lab1\pic\屏幕截图 2025-10-07 195348.png)

继续执行到断点到**内核启动执行**。OpenSBI 完成相关工作后，跳转到`0x80200000`地址，开始执行`kern/init/entry.S`

```
(gdb) c
Continuing.
Breakpoint 1, kern_entry () at kern/init/entry.S:7
7	    la sp, bootstacktop
```

![](D:\Desktop\各科任务\大三\大三上\操作系统\实验\Lab1\pic\屏幕截图 2025-10-07 195644.png)

设置断点

```
(gdb) break kern_init
Breakpoint 2 at 0x8020000a: file kern/init/init.c, line 8.
```

![](D:\Desktop\各科任务\大三\大三上\操作系统\实验\Lab1\pic\屏幕截图 2025-10-07 195700.png)

可以看到接下来是一段循环代码

```assembly
(gdb) disassemble kern_init
Dump of assembler code for function kern_init:
   0x000000008020000a <+0>:	auipc	a0,0x3
   0x000000008020000e <+4>:	addi	a0,a0,-2 # 0x80203008
   0x0000000080200012 <+8>:	auipc	a2,0x3
   0x0000000080200016 <+12>:	addi	a2,a2,-10 # 0x80203008
   0x000000008020001a <+16>:	addi	sp,sp,-16
   0x000000008020001c <+18>:	li	a1,0
   0x000000008020001e <+20>:	sub	a2,a2,a0
   0x0000000080200020 <+22>:	sd	ra,8(sp)
   0x0000000080200022 <+24>:	jal	ra,0x802004b6 <memset>
   0x0000000080200026 <+28>:	auipc	a1,0x0
   0x000000008020002a <+32>:	addi	a1,a1,1186 # 0x802004c8
   0x000000008020002e <+36>:	auipc	a0,0x0
   0x0000000080200032 <+40>:	addi	a0,a0,1210 # 0x802004e8
   0x0000000080200036 <+44>:	jal	ra,0x80200056 <cprintf>
   0x000000008020003a <+48>:	j	0x8020003a <kern_init+48>
End of assembler dump.
```

![](D:\Desktop\各科任务\大三\大三上\操作系统\实验\Lab1\pic\屏幕截图 2025-10-07 195953.png)

继续执行，debug窗口出现输出

```
(THU.CST) os is loading ...
```

![](D:\Desktop\各科任务\大三\大三上\操作系统\实验\Lab1\pic\屏幕截图 2025-10-07 200444.png)

### 练习

对实验报告的要求：

- 基于markdown格式来完成，以文本方式为主
- 填写各个基本练习中要求完成的报告内容
- 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
- 列出你认为OS原理中很重要，但在实验中没有对应上的知识点

#### 练习1：理解内核启动中的程序入口操作

阅读 kern/init/entry.S内容代码，结合操作系统内核启动流程，说明指令 la sp, bootstacktop 完成了什么操作，目的是什么？ tail kern_init 完成了什么操作，目的是什么？

```
la sp, bootstacktop
```

**操作：**
`la` 是汇编中的“load address”指令，将符号 `bootstacktop` 的地址加载到寄存器 `sp`（栈指针）中。

**目的：**
设置内核启动时的栈顶指针。这样后续内核代码执行时，所有函数调用、局部变量等都能在内核栈上正确工作，避免栈溢出或非法访问。简而言之，确保内核在进入 C 语言环境（如 kern_init 函数）时有一个合法的栈空间，用于支持函数调用和返回。

```
tail kern_init
```

**操作：**
`tail` 指令是无条件跳转到 `kern_init`，并且不会返回（类似于 C 语言中的 `goto` 或 `jmp`，但会替换当前调用帧）。

**目的：**
直接跳转到内核初始化主函数 `kern_init`，开始执行内核的初始化流程。由于是 `tail` 跳转，不会保留返回地址，表示内核初始化后不会再回到 `kern_entry`，这是内核启动的正式入口。

#### 练习2: 使用GDB验证启动流程

为了熟悉使用 QEMU 和 GDB 的调试方法，请使用 GDB 跟踪 QEMU 模拟的 RISC-V 从加电开始，直到执行内核第一条指令（跳转到 0x80200000）的整个过程。通过调试，请思考并回答：RISC-V 硬件加电后最初执行的几条指令位于什么地址？它们主要完成了哪些功能？请在报告中简要记录你的调试过程、观察结果和问题的答案。

1. **跟踪启动流程**

   - **阶段 1：CPU 从复位地址 0x1000 开始**
     在 GDB 中设置断点：b *0x1000，然后运行 c（continue）。发现 CPU 从 0x1000 地址开始执行，这是 QEMU 模拟的复位地址，运行的是 MROM（Machine ROM）代码。
   - **阶段 2：OpenSBI 初始化和内核加载**
     设置观察点：watch *0x80200000，监控内核加载到 0x80200000 的瞬间。继续运行（c），当内核镜像被加载到 0x80200000 时，GDB 暂停。使用 x/10i 0x80200000 查看该地址的指令，确认是 entry.S 的代码（la sp, bootstacktop 等）。
   - **阶段 3：跳转到内核入口**
     设置断点：b *0x80200000，继续运行（c）。当 PC 到达 0x80200000 时，GDB 暂停，单步执行（si）验证 entry.S 的代码，确认 la sp, bootstacktop 和 tail kern_init 的执行。

2. **问题回答**

   - **RISC-V 硬件加电后最初执行的地址**：
     CPU 从复位地址 **0x1000** 开始执行，这是 QEMU 模拟的 MROM 入口地址，直到**0x1010**。

     ```assembly
     0x1000: auipc t0, 0x0
     ```

     初始化 t0 为当前代码的基地址，用于后续的相对寻址

     ```assembly
     0x1004: addi a1, t0, 32
     ```

     ```assembly
     0x1008: csrr a0, mhartid
     ```

     获取当前执行的硬件线程 ID，作为参数传递给后续代码

     ```ass
     0x100c: ld t0, 24(t0)
     ```

     从地址 0x1018 加载一个值到 t0

     ```
     0x1010: jr t0
     ```

     将控制权移交到 OpenSBI，完成 MROM 的任务，进入固件初始化阶段

------

## 总结

通过实验，我深入理解了 RISC-V 内核启动的汇编代码（entry.S）和 OpenSBI 的作用，掌握了 QEMU 和 GDB 的调试方法。la sp, bootstacktop 和 tail kern_init 是内核入口的关键步骤，分别初始化栈和跳转到 C 语言环境。调试过程验证了从 0x1000（MROM）到 0x80000000（OpenSBI）再到 0x80200000（内核入口）的启动流程。实验中的知识点与 OS 原理中的引导程序、运行时环境初始化等密切相关，但实验简化了多阶段引导和中断处理等内容，为后续实验留下了扩展空间。

